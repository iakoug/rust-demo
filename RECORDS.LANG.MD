- 栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）。
  栈是自顶向下增长的，一个程序的调用栈最底部，除去入口帧（entry frame），就是 main() 函数对应的帧，而随着 main() 函数一层层调用，栈会一层层扩展；调用结束，栈又会一层层回溯，把内存释放回去。在调用的过程中，一个新的帧会分配足够的空间存储寄存器的上下文。在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文，就像什么都没有经历一样。此外，函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来。

函数运行时，怎么确定究竟需要多大的帧呢？这要归功于编译器。在编译并优化代码的时候，一个函数就是一个最小的编译单元。在这个函数里，编译器得知道要用到哪些寄存器、栈上要放哪些局部变量，而这些都要在编译时确定。所以编译器就需要明确每个局部变量的大小，以便于预留空间。这下我们就明白了：在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上

字符串的数据结构，在编译时大小不确定，运行时执行到具体的代码才知道大小。比如上面的代码，“Lindsey” 和 “Rosie” 的长度不一样，say_name() 函数只有在运行的时候，才知道参数的具体的长度。所以，我们无法把字符串本身放在栈上，只能先将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存。

栈虽然使用起来很高效，但它的局限也显而易见。当我们需要动态大小的内存时，只能使用堆，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上。堆上分配内存时，一般都会预留一些空间，这是最佳实践。

除了动态大小的内存需要被分配到堆上外，动态生命周期的内存也需要分配到堆上。

栈上的内存不必特意释放，顶多是编译时编译器不再允许该变量被访问。因为栈上的内存会随着栈帧的结束而结束

- 结构体的内存分配
  结构体中的每个域（字段）都有长度和对齐长度
  长度：指字段（域）类型占用的字节数。例如：

int 在 32 位系统中占 4 个字节
char 占 1 个字节
对齐长度：为了加快访问，编译器要求字段的起始地址必须是某个特定字节边界的倍数（即对齐边界）。

基本类型的对齐长度一般等于其大小。例如，int 的对齐长度通常是 4 字节，char 是 1 字节。 2. 每个字段的起始位置要与其对齐长度对齐
如果一个字段的起始地址不是它的对齐边界的倍数，编译器会在前面添加 padding（填充字节），使其对齐。
这种填充会浪费一些内存，但能提高 CPU 访问的效率。

- 析构函数（Destructor）是在对象生命周期结束时自动调用的特殊函数，用于执行清理操作。它通常用于释放对象所占用的资源，比如动态分配的内存、文件句柄、网络连接等。
  析构函数的主要用途包括：

  释放资源：如动态分配的内存、打开的文件等。
  执行清理操作：如关闭网络连接、释放线程等。
  维护对象状态：确保在对象被销毁时完成必要的操作。


- TEXT 段：存储程序的机器指令（代码），只读且可执行。
RODATA 段：存储只读的常量数据，如字符串字面量，确保它们不可修改。

为何要区分 TEXT 和 RODATA 段？
内存保护和安全性：
将代码和常量数据放在只读段可以防止程序错误地修改它们，这有助于防范缓冲区溢出攻击或其他类型的漏洞。

优化性能：
操作系统可以将 TEXT 和 RODATA 段加载到内存中并应用优化（如缓存）。

简化内存管理：
常量数据和代码只需加载一次，不需要额外的管理逻辑来跟踪它们的状态。

在计算机系统的可执行文件（如 ELF 文件）或内存布局中，TEXT 和 RODATA 是常见的段（section），它们用于存储程序中的不同类型的数据。