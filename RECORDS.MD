- Rust 的整体语法偏 C/C++ 风格。函数体用花括号 {} 包裹，表达式之间用分号 ; 分隔，访问结构体的成员函数或者变量使用点 . 运算符，而访问命名空间（namespace）或者对象的静态函数使用双冒号 :: 运算符。如果要简化对命名空间内部的函数或者数据类型的引用，可以使用 use 关键字，比如 use std::fs

- 在 Rust 中，unit 类型是 ()，表示一个空值或无返回值的类型。它类似于其他语言中的 void，但在 Rust 中是一个实际的类型

- rust 函数中，如果最后一个表达式没有以；结尾，那么最后一个表达式就是它的返回值。如果以；结尾则返回 unit，如果在函数中需要提前返回则使用 return

- 在 Rust 中，{:?} 和 {:#?} 是用于格式化输出的占位符，通常在打印结构体、枚举或其他类型的值时使用。它们都与 Debug trait 相关，允许你以调试格式输出类型的值

- 在 Rust 中，双冒号（::）用于路径引用，以便访问模块、类型或结构体中的项。当双冒号放在最前面时（如 ::std::），它表示使用绝对路径引用，从 crate 根 开始。这种机制确保了代码的模块化和名称空间的管理，有助于避免命名冲突

- !标记宏调用

- 在 Rust 中，Some 是 Option 枚举的一部分，用来表示一个可能存在也可能不存在的值。Rust 使用 Option<T> 类型来代替其他语言中的 null，从而避免了常见的空值错误（如 NullPointerException）。

- 在 Rust 中，impl 块相当于类中的方法定义。你可以在 impl 块中为结构体添加方法（类似于类的成员函数）。

- 在 Rust 中，Self 是一个特殊的类型，代表当前结构体、枚举或 trait 的实现类型。它通常用于实现方法、trait 的关联类型、或者作为类型的占位符
  Self 是 Rust 中的一个特殊类型，用于表示当前类型。
  它在结构体和 trait 的实现中非常有用，能够提高代码的清晰度和灵活性。
  你可以在方法定义、trait 定义和类型别名中使用 Self

- Rust 的宏主要分为 声明式宏（Declarative Macros） 和 过程宏（Procedural Macros）。

  声明式宏类似于 模式匹配，使用 macro_rules! 来定义。它根据输入的模式匹配并生成相应的代码。
  过程宏是 自定义的编译器插件，可以在 编译时生成复杂代码。它们本质上是 函数，接收 TokenStream（标记流）作为输入，并返回 修改后的 TokenStream。过程宏适合复杂的代码生成和元编程。

  过程宏的分类
  派生宏（Derive Macros）：自动为类型生成代码，如 #[derive(Debug, Clone)]。
  属性宏（Attribute Macros）：自定义属性，用于修改函数或模块的行为。
  函数宏（Function-like Macros）：类似函数的调用，但编译时生成代码。

- &str 是不可变的字符串切片，适合用作引用和轻量级的数据传递。
  String 是可变的字符串类型，适合用来动态管理字符串数据。

- 闭包是匿名函数 let add = |x, y| x + y;
  Rust 中的闭包可以通过以下三种方式捕获变量：

  按值（move）
  不可变借用（&T）
  可变借用（&mut T）

  函数的类型是显式的，需要明确参数和返回值类型。
  闭包的参数类型可以由编译器推断，不一定需要手动标明。

- 当你使用 泛型 或 trait，Rust 在编译时会为每一种具体类型生成独立的代码。这种机制使得泛型代码在运行时没有性能开销。
  在 Rust 中，单态化 (monomorphization) 是指 编译器为每个泛型类型的具体使用场景生成单独的代码。这是一种重要的优化技术，可以在运行时避免类型开销，并提高程序性能。然而，单态化也会导致 编译产物（最终生成的二进制文件）变大。

- 在 Rust 中，Turbofish (::<...>) 是一种用于显式指定泛型类型参数的语法。当编译器无法通过上下文推导出某些泛型类型时，Turbofish 允许开发者手动提供这些类型，以确保类型推导的正确性。
  function_name::<Type1, Type2>(arguments);

- 悬垂引用（Dangling Reference）是指引用指向的内存已经被释放或无效，但程序仍尝试访问这块内存。这种情况会导致未定义行为，可能引发程序崩溃或数据损坏。Rust 语言通过**借用检查器（borrow checker）**和所有权系统有效地防止了这种错误。

- 当我们进行变量赋值、传参和函数返回时，如果涉及的数据结构没有实现 Copy trait，就会默认使用 Move 语义转移值的所有权，失去所有权的变量将无法继续访问原来的数据；如果数据结构实现了 Copy trait，就会使用 Copy 语义，自动把值复制一份，原有的变量还能继续访问

- 引用

  - 一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
  - 如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。
  - 一个值可以有多个只读引用。
  - 一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。
  - 引用的生命周期不能超出值的生命周期。

  - 所有权

    - 所有权：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。
    - Move 语义：赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
    - Copy 语义：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。

- 在 Rust 中，as *const i32 是一种类型转换，它将一个引用（&T）转换为指向常量的原始指针（*const T）。这是 Rust 中进行安全指针转换的常用语法。

- Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。我们后续讲到智能指针时会详细介绍 Box。Box::leak()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。

- 进一步理解 Rust 是如何进行所有权的静态检查和动态检查了：
  静态检查，靠编译器保证代码符合所有权规则；
  动态检查，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放

- 如果想绕过“一个值只有一个所有者”的限制，我们可以使用 Rc / Arc 这样带引用计数的智能指针。其中，Rc 效率很高，但只能使用在单线程环境下；Arc 使用了原子结构，效率略低，但可以安全使用在多线程环境下。然而，Rc / Arc 是不可变的，如果想要修改内部的数据，需要引入内部可变性，在单线程环境下，可以在 Rc 内部使用 RefCell；在多线程环境下，可以使用 Arc 嵌套 Mutex 或者 RwLock 的方法。

- 如果一个值的生命周期贯穿整个进程的生命周期，那么我们就称这种生命周期为静态生命周期
  当值拥有静态生命周期，其引用也具有静态生命周期。我们在表述这种引用的时候，可以用 'static 来表示。比如： &'static str 代表这是一个具有静态生命周期的字符串引用。一般来说，全局变量、静态变量、字符串字面量（string literal）等，都拥有静态生命周期。我们上文中提到的堆内存，如果使用了 Box::leak 后，也具有静态生命周期。

  - 分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的。
  - 全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。因而，它们的生命周期和进程的生命周期一致，所以是静态的。
  - 所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。

- 编译器会通过一些简单的规则为函数自动添加标注：
  所有引用类型的参数都有独立的生命周期 'a 、'b 等。
  如果只有一个引用型输入，它的生命周期会赋给所有输出。
  如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。

  生命周期标注的目的是，在参数和返回值之间建立联系或者约束。调用函数时，传入的参数的生命周期需要大于等于（outlive）标注的生命周期。
  数据结构的生命周期标注也是类似，结构本身的生命周期不能大于属性的生命周期

  根据所有权规则，值的生命周期可以确认，它可以一直存活到所有者离开作用域；而引用的生命周期不能超过值的生命周期。在同一个作用域下，这是显而易见的。然而，当发生函数调用时，编译器需要通过函数的签名来确定，参数和返回值之间生命周期的约束。大多数情况下，编译器可以通过上下文中的规则，自动添加生命周期的约束。如果无法自动添加，则需要开发者手工来添加约束。一般，我们只需要确定好返回值和哪个参数的生命周期相关就可以了。而对于数据结构，当内部有引用时，我们需要为引用标注生命周期。

  - 在 Rust 中，顶层无法使用 let 声明变量是因为 Rust 只允许在函数体内、代码块或模块内部进行变量的绑定
    变量通常在一个块中有效，例如函数体或循环。Rust 不允许在顶层（模块级别）直接使用 let 进行变量绑定，因为这可能导致作用域不明确或意外的绑定。
    如果你希望在模块级别定义常量或静态变量，可以使用 const 或 static
    const：用于定义常量，类型必须显式指定，常量在编译时确定其值。
    static：用于定义静态变量，具有固定的内存地址，可以在运行时修改（需注意线程安全）。

- 在 Rust 中，unwrap 是一个用于处理 Option 和 Result 类型的方法，它可以从这些类型中提取值。使用 unwrap 可以简化代码，但也需要谨慎使用，因为它会在提取失败时导致程序 panic（崩溃）。
  只是写一些学习性质的代码，那么 unwrap() 是可以接受的，但在生产环境中，除非你可以确保 unwrap() 不会引发 panic!()，否则应该使用模式匹配来处理数据，或者使用错误处理的 ? 操作符。我们后续会有专门一讲聊 Rust 的错误处理。那什么情况下我们可以确定 unwrap() 不会 panic 呢？如果在做 unwrap() 之前，Option 或者 Result 中已经有合适的值（Some(T) 或者 Ok(T)），你就可以做 unwrap()

- 在 Rust 中，Vec<_> 中的 _ 是一种 类型占位符，表示类型推断。Rust 编译器会根据上下文自动推断出 Vec 中存储的元素类型，因此我们不需要手动指定具体类型。

- 在泛型函数后使用 :: 来强制使用类型 T，这种写法被称为 turbofish

- ::Owned 的含义：它对 B 做了一个强制类型转换，转成 ToOwned trait，然后访问 ToOwned trait 内部的 Owned 类型。因为在 Rust 里，子类型可以强制转换成父类型，B 可以用 ToOwned 约束，所以它是 ToOwned trait 的子类型，因而 B 可以安全地强制转换成 ToOwned

- 对于泛型函数，Rust 会进行单态化（Monomorphization）处理，也就是在编译时，把所有用到的泛型函数的泛型参数展开，生成若干个函数。

- 按类型定义、检查以及检查时能否被推导出来，Rust 是强类型 + 静态类型 + 显式类型
  在少数情况下，Rust 无法通过上下文进行类型推导，我们需要为变量显式地标注类型，或者通过 turbofish 语法，为泛型函数提供一个确定的类型。有个例外是在 Rust 代码中定义常量或者静态变量时，即使上下文中类型信息非常明确，也需要显式地进行类型标注

- 什么是 trait？trait 是 Rust 中的接口，它定义了类型使用这个接口的行为。你可以类比到自己熟悉的语言中理解，trait 对于 Rust 而言，相当于 interface 之于 Java、protocol 之于 Swift、type class 之于 Haskell。

- b"..." 用于生成 字节字符串，它的类型是 &[u8]，适合处理二进制数据。
  与普通字符串不同，字节字符串只支持 ASCII 字符，不支持 Unicode。
  在 IO 操作（如 write_all）中，字节字符串非常常用，因为它能直接作为 二进制数据 传递。

- 在 Rust 中，关联类型（Associated Types）是定义在 trait 中的一种类型占位符，用于使实现某个 trait 的类型可以指定具体的类型。它们是一种简化泛型的方式，避免在使用 trait 时重复传递多个泛型参数。

关联类型的典型场景是定义类型间的关系，如运算符重载时，我们希望类型能在不同实现之间动态指定类型结果。

- 如何判断一个函数是关联函数还是实例方法？
  特征 关联函数 实例方法
  是否包含接收者 没有 self 参数 有 self / &self / &mut self
  调用方式 通过类型调用：Type::func() 通过实例调用：instance.method()
  是否需要实例 不需要 需要
